```swift
var breeds = CurrentValueSubject<[String], Error>([String]())


private func setupBindings() {
    viewModel.breeds
        .receive(on: DispatchQueue.main)
        .catch{ error -> Just<[String]> in
            return Just([])
        }
        .sink(receiveValue: { [weak self] _ in
            self?.applySnapshot()
        })
        .store(in: &cancellables)
}


currentSnapshot.appendItems(viewModel.breeds.value)

```



```swift
import Foundation


/// Errors that will be generated by the NetworkManager
public enum NetworkError: Error, Equatable {
    case bodyInGet
    case invalidURL
    case noInternet
    case invalidResponse(Data?, URLResponse?)
    case accessForbidden
}

public enum HTTPMethod: String {
    case get = "GET"
    case post = "POST"
    case put = "PUT"
    case delete = "DELETE"
    case patch = "PATCH"
}

public class NetworkManager<T: URLSessionProtocol> {
    public let session: T
    
    var cacheManager: CacheManagerProtocol
    
    required init(session: T, cacheManager: CacheManagerProtocol = CacheManager.shared) {
        self.session = session
        self.cacheManager = cacheManager
    }
    
    public func fetch(url: URL, method: HTTPMethod, headers: [String : String] = [:], token: String? = nil, data: [String: Any]? = nil, completionBlock: @escaping (Result<Data, Error>) -> Void) {
        // make network request
        if method == .get {
            guard data == nil else {
                completionBlock(.failure(NetworkError.bodyInGet))
                return
            }
        }
        
        var request = URLRequest(url: url, cachePolicy: .useProtocolCachePolicy, timeoutInterval: 30.0)
        request.httpMethod = method.rawValue
        request.allHTTPHeaderFields = headers
        
        if let bearerToken = token {
            request.setValue("Bearer \(bearerToken)", forHTTPHeaderField: "Authorization")
        }
        
        if let data = data {
            var serializedData: Data?
            do {
                serializedData = try JSONSerialization.data(withJSONObject: data, options: .prettyPrinted)
            } catch {
                completionBlock(.failure( ErrorModel(errorDescription: "Could not serialize data") ))
            }
            request.httpBody = serializedData
        }
        
        cacheManager.fetchDataFromCache(request: request, completion: { [weak self] data in
            
            if let data = data {
                print ("return from cache")
                completionBlock(.success(data))
                return
            }
            
            print ("make data call")


            let task = session.dataTask(with: request) { data, response, error in

                guard error == nil else {
                    completionBlock(.failure(error!))
                    return
                }
                guard
                    let _ = data,
                    let httpResponse = response as? HTTPURLResponse,
                    200 ..< 300 ~= httpResponse.statusCode else {
                        if let data = data {
                            completionBlock(.success(data))
                        } else {
                            completionBlock(.failure(NetworkError.invalidResponse(data, response)))
                        }
                        return
                }
                // if passed guard
                if let data = data {
                    completionBlock(.success(data))
                    self?.cacheManager.storeDataToCache(request: request, data: data)
                }
            }
            task.resume()
            
            }
        )
    }
}


import Foundation

// Use a dictionary
final class CacheManager: CacheManagerProtocol {
    private var cache: [URLRequest: Data] = [:]
    
    static var shared = CacheManager()
    
    private init() {}
    
    func fetchDataFromCache(request: URLRequest, completion: ((Data?) -> ())) {
        completion(cache[request])
    }
    
    func storeDataToCache(request: URLRequest, data: Data) {
        print ("Stored to Cache")
        cache[request] = data
    }
    
    subscript(request: URLRequest) -> Data? {
         get {
             return cache[request]
         }

         set {
             if let object = newValue {
                 cache[request] = object
             } else {
                 cache[request] = nil
             }
         }
     }
}


```


```
swift
let cache = NSCache<NSString, ExpensiveObjectClass>()
let myObject: ExpensiveObjectClass

if let cachedVersion = cache.object(forKey: "CachedObject") {
    // use the cached version
    myObject = cachedVersion
} else {
    // create it from scratch then store in the cache
    myObject = ExpensiveObjectClass()
    cache.setObject(myObject, forKey: "CachedObject")
}
```


```
swift

extension UIImageView {
    /// Loads image from web asynchronosly and caches it, in case you have to load url
    /// again, it will be loaded from cache if available
    func load(url: URL, placeholder: UIImage?, cache: URLCache? = nil) {
        let cache = cache ?? URLCache.shared
        let request = URLRequest(url: url)
        if let data = cache.cachedResponse(for: request)?.data, let image = UIImage(data: data) {
            self.image = image
        } else {
            self.image = placeholder
            URLSession.shared.dataTask(with: request, completionHandler: { (data, response, error) in
                if let data = data, let response = response, ((response as? HTTPURLResponse)?.statusCode ?? 500) < 300, let image = UIImage(data: data) {
                    let cachedData = CachedURLResponse(response: response, data: data)
                    cache.storeCachedResponse(cachedData, for: request)
                    DispatchQueue.main.async {
                        self.image = image
                    } 
                }
            }).resume()
        }
    }
}
```
