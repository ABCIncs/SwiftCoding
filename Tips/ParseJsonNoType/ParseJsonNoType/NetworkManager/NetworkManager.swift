//
//  NetworkManager.swift
//  ParseJsonNoType
//
//  Created by Steven Curtis on 06/08/2020.
//  Copyright Â© 2020 Steven Curtis. All rights reserved.
//

import Foundation


struct ErrorModel: Error {
    var errorDescription: String
}

// Errors that will be generated by the NetworkManager
enum NetworkError: Error, Equatable {
    case invalidURL
    case noInternet
    case invalidResponse(Data?, URLResponse?)
    case accessForbidden
}

public enum HTTPMethod: String {
    case get = "GET"
    case post = "POST"
}

class NetworkManager<T: URLSessionProtocol> {
    let session: T
    
    required init(session: T) {
        self.session = session
    }
    
    public func fetch(url: URL, method: HTTPMethod, headers: [String : String], token: String?, data: [String: Any]?, completionBlock: @escaping (Result<Data, Error>) -> Void) {
        
        var request = URLRequest(url: url, cachePolicy: .reloadIgnoringLocalCacheData, timeoutInterval: 30.0)
        request.httpMethod = method.rawValue
        request.allHTTPHeaderFields = headers
        
        
        if let bearerToken = token {
            request.setValue("Bearer \(bearerToken)", forHTTPHeaderField: "Authorization")
        }
        
        if let data = data {
            var serializedData: Data?
            
            do {
                serializedData = try JSONSerialization.data(withJSONObject: data, options: .prettyPrinted)
            } catch {
                completionBlock(.failure( ErrorModel(errorDescription: "Could not serialize data") ))
            }
            
            request.httpBody = serializedData
        }
        
        let task = session.dataTask(with: request) { data, response, error in
            guard error == nil else {
                completionBlock(.failure(error!))
                return
            }
            guard
                let _ = data,
                let httpResponse = response as? HTTPURLResponse,
                200 ..< 300 ~= httpResponse.statusCode else {
                    if let data = data {
                        completionBlock(.success(data))
                    } else {
                        completionBlock(.failure(NetworkError.invalidResponse(data, response)))
                    }
                    return
            }
            // if passed guard
            if let data = data {
                completionBlock(.success(data))
            }
        }
        task.resume()
    }
    
}
